## 如何登陆
我们假设你已经知道如何构建登录+密码HTML表单，该表单将值POST到服务器端的脚本以进行身份验证。接下来将讨论常见的登陆设计模式，以及如何避免最常见的安全陷阱。

### HTTPS的使用
除非连接已经安全（即通过HTTPS使用SSL / TLS进行隧道传输），否则登录表单值将以明文形式发送，任何窃听浏览器和Web服务器之间的线路的机制都可以获取这些登录信息。此类的窃听一般是由政府定期完成的，就算使用专线光纤，也可以使用特殊方法监听通讯，如果要保护任何重要信息，使用**HTTPS**。

实质上，在登录期间防止窃听/数据包嗅探的唯一实用方法是使用HTTPS或其他基于证书的加密方案（例如，TLS）或经过 a proven & tested challenge-response scheme（例如，Diffie-Hellman） 基于SRP）。窃听攻击者可以轻易地绕过任何其他方法。

当然，如果异想天开的话，还可以采用某种形式的双因素身份验证方案（例如Google身份验证器应用程序，物理“冷战风格”代码簿或RSA密钥生成器加密狗）。 如果应用正确，即使使用不安全的连接，这也可以工作，但很难想象开发人员愿意实现双因素身份验证而不是SSL。

### 不要使用JavaScript encryption/hashing
鉴于的网站上设置SSL证书需要花钱，并且有一定技术复杂度，一些开发人员倾向于推出他们自己的浏览器内Hash加密方案，以避免在不安全的线路进行明文登录。

这虽然是一个很好的想法，但基本上没用（并且可能是一个安全漏洞），除非它与上述之一相结合 - 也就是说，要么使用强加密来保护线路，要么 tried-and-tested challenge-response 机制（最难以证明的，最难设计的，也是最难实现的数字安全概念）

虽然散列密码可以有效防止密码泄露，但它很容易受到重放攻击（replay attacks），中间人攻击/劫持（如果攻击者在到达你的不受保护的HTML页面之前可以注入几个字节） 浏览器，他们可以简单地注释掉JavaScript中的哈希），或者暴力攻击（因为你正在向攻击者发送用户名，盐和哈希密码）。

### CAPTCHAs

CAPTCHAs旨在阻止一种特定类型的攻击：不需要人工干预的自动字典/暴力破解试验和错误。 毫无疑问，这是一个真正的威胁，但有一些方法可以无缝地处理它，不需要CAPTCHA，特别是正确设计的服务器端登录限制方案。

CAPTCHA存在各种实现方式，通常对精心设计的破解方式无效，同时对廉价的印度非洲劳动力无效（根据OWASP，目前500人工破解的价格约为12美元），并且一些实验方式可能是技术上非法的。参考[https://www.owasp.org/index.php/Authentication_Cheat_Sheet OWASP Authentication Cheat Sheet]。此处推荐Google的reCAPTCHA，其被定义为OCR-hard（使用OCR错误分类的书籍内容进行扫描），并努力尝试做到用户友好性。

发现CAPTCHAS很烦人，并且当用户多次登录失败并且限制延迟时间达到最大时，将它们用作最后的手段，并且它会加强整个系统的安全性。

### 保存密码/验证登陆
在我们近年来看到的所有高度公开的黑客攻击和用户数据泄漏之后，必须说明：**不要在数据库中以明文形式存储密码**。 用户数据库通常会通过SQL注入被黑客入侵，泄露或收集，如果您要存储原始明文密码，登录安全性就彻底说拜拜了。

如果无法存储密码，如何检查登录表单中登录的登录名+密码组合是否正确？答案是使用密钥派生函数进行Hash。无论何时创建新用户或更改密码，您都会获取密码并通过KDF（例如Argon2，bcrypt，scrypt或PBKDF2）运行密码，将明文密码（“correcthorsebatterystaple”）转换为长而随机的字符串，实现更安全的存储。要验证登录，请对输入的密码运行相同的哈希函数，这次传入salt并将生成的哈希字符串与存储在数据库中的值进行比较。Argon2，bcrypt和scrypt已经将哈希值与哈希一起存储。参考：[https://security.stackexchange.com/questions/211/how-to-securely-hash-passwords/31846#31846 Password Hash Functions]

使用salt的原因是因为散列本身是不够的，你需要添加一个所谓的**salt**来保护散列不受彩虹表（rainbow table）的影响。**salt**有效地防止两个完全匹配的密码被存储为相同的哈希值，从而防止在攻击者描整个数据库执行密码猜测攻击。

加密Hash不应该被用于存储密码，因为用户选定的密码不够强大（即通常不包含足够的熵）和密码猜测攻击可以在相对短的时间内完成（访问Hash值）。这就是使用KDF的原因，每个密码都会涉及多次迭代哈希算法，例如10,000次，这使得攻击者的密码猜测速度慢了10,000倍。

### Session data
一旦服务器针对您的用户数据库验证了登录名和密码并找到匹配项，系统就需要一种方法来记住浏览器已经过身份验证。这就是Session，必须保存至服务器端。

如果可能的话，确保会话cookie在发送到浏览器时设置了安全和仅HTTP标志。 httponly标志提供一些保护，防止XSS攻击读取cookie。安全标志确保cookie仅通过HTTPS发回，因此可以防止网络嗅探攻击。cookie的值应该是不可预测的。如果cookie引用了不存在的session，应该立即替换cookie防止[Session Fixation](https://www.owasp.org/index.php/Session_fixation)。

## 如何记住用户登陆 
持久登录Cookie（“记住我”功能）是一个危险区域：一方面，当用户了解如何处理它们时，它们完全像传统登录一样安全；另一方面，它们在粗心用户手中是一个巨大的安全风险，他们可能在公共计算机上使用它们而忘记注销，并且可能不知道浏览器cookie是什么或如何删除它们。有些系统无法承受任何帐户黑客入侵，对于这样的系统，不要提供持久登录功能。
* 参考：[Implementing Secure User Authentication in PHP Applications with Long-Term Persistence (Login with "Remember Me" Cookies)](https://paragonie.com/blog/2015/04/secure-authentication-php-with-long-term-persistence)
* **不要再数据库中存储持久Cookie（登陆令牌），只保存其Hash值**。登陆令牌和密码是等效的，如果数据库被破解，攻击者可以使用登陆令牌登陆任何一个账户，参考：https://security.stackexchange.com/a/63438/5002

## 使用安全问题 
不要实施“安全问题”。“安全问题”功能是一种安全反模式。即使有用户指定的问题，大多数用户也很可能会选择：

* 一个**标准**安全问题，如母亲的姓或宠物；
* 一个简单的琐事，任何人都可以从他们的博客，LinkedIn个人资料或类似的东西；
* 任何比猜测密码更容易回答的问题。

总之，安全问题本质上在其所有形式和变体中都是不安全的，并且不应出于任何原因在认证方案中使用。安全问题存在的意义在于，减少用户通过电子邮件获取账户重新激活代码的额外成本，应该用更有效的方式替代。

## 忘记密码功能 
不应该使用安全问题来处理忘记/丢失的用户密码，也绝不应该通过电子邮件向用户发送他们的实际密码。在这个领域至少还有两个需要避免的常见缺陷：

不要将忘记的密码重置为自动生成的强密码：这种密码非常难以记住，这意味着用户必须更改密码或将其写下来，例如，在显示器边缘的亮黄色便条上。**只需让用户立即选择一个新密码（或使用密码管理器来存储/管理通常无法记住的密码）**。

丢失密码代码也需要在数据库中进行Hash保存，以防止攻击者获取数据库权限。当请求丢失密码代码时，将明文代码发送到用户的电子邮件地址，然后对其进行哈希处理，将哈希值保存在数据库中，然后丢弃原始密码。

最后一点：始终确保用于输入“丢失密码代码”的界面至少与登录表单本身一样安全，否则攻击者将使用它来获取访问权限。确保生成很长的“丢失密码代码”，考虑添加与登录表单相同的请求限流方案。

## 检验密码强度 
人们通常选择的密码强度会非常差，没有最低密码强度要求，2％的用户使用前20个最常用的密码之一。含义：如果攻击者只获得20次尝试，则您网站上50个帐户中的1个将被破解。如果放任用户自行选择密码，将导致严重的账户被盗隐患。

阻止这一点需要计算密码的熵，然后应用阈值。美国国家标准与技术研究院（NIST）[特刊800-63](http://en.wikipedia.org/wiki/Password_strength#NIST_Special_Publication_800-63)提出了一系列非常好的建议。当与字典和键盘布局分析相结合时（例如，'qwertyuiop'是一个错误的密码），可以在18位熵的水平上拒绝99％的所有选择不当的密码。简单地计算密码强度并向用户显示视觉强度计是好的，但是不够。除非强制执行，否则许多用户很可能会忽略它。

获得高熵密码必要性的漫画图示：https://xkcd.com/936/。

## 防止快速登陆尝试

* 破解弱密码几乎不需要任何时间
* 如果密码长度小于8个字符（不包含8个），复杂符号+字母大小写+数字构成的密码也可以使用普通PC破解，最多几个小时。
* 但是如果给每次破解尝试加一个时间限制（每次一秒钟），即便破解6个字符的密码也需要大量的时间。

阻止大量快速连续登陆尝试（暴力攻击 brute force attack）并不十分复杂，有三种选择可以有效的抵御暴力攻击（由于已经采用了强密码策略，字典攻击应该不是问题）：
* 在N次尝试失败后，出现CAPTCHA
* 在N次尝试失败后，锁定账户并要求电子邮件验证
* 登陆限流策略，N次登陆失败之后设置下次尝试的最小时间间隔
** 限流期间，根本不会接受或特定帐户或特定IP地址的登录尝试

登陆限流策略举例1
* 第一次登陆失败，没有延迟
* 2次登陆失败，2秒延迟
* 3次登陆失败，4秒延迟
* 4次登陆失败，8秒延迟
* 5次登陆失败，16秒延迟
* 等等

登陆限流策略举例2
* 1 failed attempt = 5 sec delay
* 2 failed attempts = 15 sec delay
* 3+ failed attempts = 45 sec delay

但是，作为经验法则，密码策略越强，延迟就越不会对的用户造成困扰。如果系统规定需要强大的（区分大小写的字母数字+所需的数字和符号）9个以上的字符密码，可以在限流策略激活之前为用户提供2-4次非延迟密码尝试。

限流策略，允许Persistent Cookie和 CAPTCHA 验证过的登录请求，使合法用户更少被限流策略所影响。通过强密码+限流策略，DoS攻击将变得极端不适用和无效。

**同时，需要对后台管理系统或管理员账户实施更加激进的管理方式。**

## 分布式暴力攻击

分布式暴力攻击的方式主要有：
* 使用僵尸网络/代理隧道防止IP标记
* 不会挑选1个用户使用50000个最常用密码进行尝试，而是使用常用密码对抗50000个用户，因此找到用户id将成为攻击的必要步骤
* 每个账户的登陆尝试大于30秒，规避限流策略

最好的做法是记录系统范围的登陆失败次数，基于登陆错误次数的平均值设定上限：
* 例如过去3个月每天有120次登陆失败次数，如果24小时内有360次登陆失败尝试，将激活系统范围内的登陆限制
* 所有用户的登陆都有短暂延迟
* Cookie登陆和CAPTCHA登陆不在限制之列

参考：https://stackoverflow.com/questions/479233/what-is-the-best-distributed-brute-force-countermeasure

## 双因素身份验证 / SSO / OAuth / OpenID
无论是利用漏洞，密码被记录下来还是丢失，密钥被盗的笔记本电脑，还是用户登录钓鱼网站，都可能使登录凭据泄露。可以使用双因素身份验证进一步保护登录，该身份验证使用带外因素，例如通过电话，SMS消息，应用程序或加密狗接收的一次性代码。

国内常用的方式是使用手机短信进行验证：
* 手机号实名认证，同时提供了简单的实名认证功能
* 用户的手机号较为唯一，更方便用户管理

身份验证可以完全委托给单点登录服务，例如微信/微博/QQ等国内大厂，有效的将问题推送给受信任的第三方。

## 参考
* [The definitive guide to form-based website authentication](https://stackoverflow.com/questions/549/the-definitive-guide-to-form-based-website-authentication)
